README

This is a Fortran 95 implementation of a Density Matrix Renormalization Group Algorithm using a Matrix Product State approximation of the wavefunction.

The MPS is optimized and evolved in time in the grandcanonical ensemble, which means that the MPS is not invariant under the Abelian symmetry generated by the total number of particles.

However a modified version of the usual TDMRG truncation procedure guarantees the conservation of the expectation value of the number of particles as described in the paper "Improving the Gutzwiller Ansatz with Matrix Product States" arXiv:1307.8416 by S. Peotta and M. Di Ventra. 

If you use and modify the code for you work, please provide a reference to the above paper.

The code is not documented so far (April 2014) but it should be easy to understand if you have knowledge of MPS-based algorithms. 
For a thorough review of MPS-based DMRG algorithm see U. Schollwock "The density-matrix renormalization group in the age of matrix product states", Annals of Physics Volume 326, 96 (January 2011).
Several comments are provided in the source files to explain the roles of the various subroutines.

The code can simulate only the Bose-Hubbard Hamiltonian with arbitrary potentials, but it is easy to implement arbitrary models with nearest-neighbour interactions. 

The code has been developed and tested on the Ubuntu 14.04 (Trusty Tahr) operating system and requires the GNU GFortran compiler (version 4.8.2 was used) and the standard LAPACK and BLAS libraries.
Alternatively the Intel Fortran Compiler (IFORT version 14.0.2 20140120) can be used along with the Math Kernel Library (MKL) in place of LAPACK and BLAS.

The makefile included with the program allows to compile both with gfortran if the COMPILER variable is specified as

COMPILER = gfortran

and with IFORT if

COMPILER = ifort

For a proper linking with the LAPACK or MKL libraries the appropriate directory paths must be specified in the makefile. 
According to your Linux distribution and/or IFORT version the flags and the directory paths may have to be changed.
For the IFORT compiler check the documentation of the MKL library.

To compile the code simply run the makefile using the command

$ make

the name of the executable is mps_grand.x

to clean up use the command

$ make clean

INPUT
The input to the program is provided by three files: mps_grand.in, potential_init.in, potential_time.in
the file mps_grand.in has the form:

160		! length of the lattice (l)
7		! local dimension of the Hilbert space (d)
1.0		! Hubbard interaction strength (u)
-1.78958129352	! chemical potential (mu)
0.05		! phase in the complex hopping term after the quench a time = 0, called also phase kick (phi)
0.05		! time step for real time evolution (dt)
2000		! number of steps of real time evolution (steps)
20		! number of steps between two consecutive measurements of the observables, only the density is calculated (osteps)
1.0e-4		! the truncation  error, or discared weight in the reduced density matrix, essential parameter for DMRG (eps)
0		! sweeps with single-site optimization plus White trick [see  S. R. White Phys. Rev. B 18, 180403 (2005)] (sweeps_White_Correction)
3		! sweeps with double-site optimization (sweeps_Double_Site)
10		! sweeps with single-site optimization (sweeps_Single_Site)
1		! minimum value of the link dimension (m_Min)
100		! maximum value of the link dimension (m_Max)

If one sets m_Min = m_Max = 1 the code performs the optimization and the time evolution of a Gutzwiller variational wavefunction.
The files potential_init.in and potential_time.in provide the initial external potential and the potential used during the time evolution, respectively.
They are a blank-separated string of real values with length equal to the lattice length. The ones provided with the code represent identically zero 
potentials (flat potentials).

OUTPUT
The output of the program consists in two files: energy.dat and density.dat.
Energy.dat is the ground state energy obtained by the local diagonalization of the effective Hamiltonian for each diagonalization starting from the first one (first row)
to the last one (last row). It is a generally a decreasing function, although it is stricly nonincreasing only during the one-site optimization. 
If the energy does not decrease on average with the local optimization then there is a chance that the code is not working properly.
The file density.dat provides the local on-site density. The first row is the initial (ground state density) and the the subsequent rows are the density calculated every
fixed number of steps specified by the variable 'osteps' in mps_grand.in.

TEST
To run a test of the program, first compile with the chosen compiler as explained above and then run the program with

./mps_grand.x

and compare the result produced in the file density.dat with the the ones provided with test.dat in the folder TEST. 
There may be differences in the last decimal digits between your results and the one in test.dat, but they are irrelevant.
The time required to run the test program is approximately 30 minutes on a computer with an AMD Athlon 64 X2 Dual Core Processor 5600+ if compiled with gfortran.
The code is not parallelized but the MKL allows for some level parallelization with almost no effort.

If you have questions or you would like to provide your own improvements to the code feel free to contact me (see my homepage http://physics.ucsd.edu/~speotta/).


22th April 2014

Sebastiano Peotta, Post-Doc in Condensed Matter Physics at University of California-San Diego

